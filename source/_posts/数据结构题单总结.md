---
title: 数据结构题单总结
date: 2025-02-21 14:42:00
---

## [洛谷P4185 - MoooTube G](https://www.luogu.com.cn/problem/P4185)

#### 并查集

#### 题意
给定一棵 $n$ 个结点的树，每条边有边权，定义任意两个结点的相关度为两点之间路径上的最小权值。有 $Q$ 次询问，每次给定 $k_i,v_i$，仅当两个结点相关度 $\ge k_i$ 时相关。求与结点 $v_i$ 相关的结点数量。

#### 题解
显然询问可以离线，$k_i$ 逐渐下降的过程中相关的点也越来越多，转化为并查集加边过程，将询问按 $k_i$ 排序，每次连接权值为 $k_i$ 的所有边，答案即为 $v_i$ 所在联通块大小。

## [洛谷P1955 - 程序自动分析](https://www.luogu.com.cn/problem/P1955)

#### 并查集

#### 题意
有一些变量 $x_1,x_2,x_3,\cdots$，给定 $n$ 个约束条件形如 $x_i = x_j$ 或 $x_i \not = x_j$，判定这些约束条件能否同时被满足。

#### 题解
注意到相等的限制维护了一些相等变量的集合，使用并查集，先合并相等的限制，对于不等的限制，若先前已经判定相等（在同一集合内），则不可能被满足。

## [洛谷P4479 - 第k大斜率](https://www.luogu.com.cn/problem/P4479)

#### 树状数组

#### 题意
二维平面上给定 $n$ 个不同的点，任意两点确定一条直线，求所有直线中斜率第 $k$ 大的。

#### 题解
$(x_i,y_i),(x_j,y_j)$ 所连直线的斜率 $=\frac{y_j-y_i}{x_j-x_i}$。二分斜率，每次检查 $>$ mid的斜率个数。考虑如何快速求解。

设 $x_j>x_i$，则所求直线满足
$$\frac{y_j-y_i}{x_j-x_i}>mid$$
$$y_j-y_i>mid(x_j-x_i)$$
$$y_j-mid\times x_j>y_i-mid\times x_i$$
按照 $y-mid\times x$ 从小到大排序，树状数组记录这个值，依次扫描，更新答案并将当前点添加到树状数组中即可，类似逆序对的求解过程，这种过程求解的问题叫做二维偏序。

时间复杂度 $O(n \log^2 n)$。

## [洛谷P1966 - 火柴排队](https://www.luogu.com.cn/problem/P1966)

#### 树状数组

#### 题意
给定两个数列 $a,b$，他们的距离定义为 $\sum (a_i-b_i)^2$。

求交换同一数列中相邻元素使距离最小的最小交换次数。

#### 题解
显然将两数列中排名相同的数放到同一位置可以构造出最小距离，考虑如何求交换次数。

假设 $a$ 数列不动，我们要动 $b$ 数列使它对齐。预处理出 $b$ 数列中每个数应该到达的位置数列 $l$，排序求逆序对即可。

## [洛谷P3605 - Promotion Counting](https://www.luogu.com.cn/problem/P3605)

#### 树状数组

#### 题意
给定一棵 $n$ 个点的树，点有点权，求以每个点为根的子树内权值大于根的权值的点的个数。

#### 题解
我们可以对树进行 $dfs$。每次搜到一个点 $x$ 时，记录 $x$ 以前搜索到的点中 $p_i>p_x$ 的个数为 $cnt_1$。搜索完 $x$ 的子树后回溯时，记录满足条件的点数为 $cnt_2$。用 $cnt_2-cnt_1$ 即可。使用树状数组统计答案。

## [洛谷P1972 - HH的项链](https://www.luogu.com.cn/problem/P1972)

#### 树状数组

#### 题意
给定一个数列，每次询问区间 $[l,r]$ 中有多少不同的数。

#### 题解
将询问离线后从右往左扫描数列，记录每个数当前最后一次出现的位置，在这个位置记录贡献。多次出现则删除之前的贡献。每次处理以当前点为左端点的区间，在右端点处求贡献的前缀和，即为区间答案。因为记录的是最后出现的位置，因此所有贡献一定被包含在了右端点左边。


## [洛谷P4113 - 采花](https://www.luogu.com.cn/problem/P4113)
#### 树状数组
#### 题意
给定一个数列，每次询问区间 $[l,r]$ 中有多少出现两次及以上的数。
#### 题解
把询问离线后从左往右扫描，记录每个数上次和上上次出现的位置，在上上次出现的位置记录贡献。每次处理以当前点为右端点的区间，答案即为 $[l,r]$ 的贡献之和，使用树状数组维护贡献。

## [洛谷P3586 - LOG](https://www.luogu.com.cn/problem/P3586)
#### 平衡树
#### 题意
维护一个长度为 $n$ 的序列，一开始都是 $0$，支持单点修改以及在这个序列上每次选出 $c$ 个正数，并将它们都减去 $1$，问能否进行 $s$ 次操作。
#### 题解
设 $≥s$ 的数有 $x$ 个，$<s$ 的数和为 $sum$，能够成功应该满足 $sum≥(c−x)\times s$。如果不满足显然不行，满足后要证明每次取有至少c个数。

考虑 $sum$，最少的时候有 $⌈\frac{sum}{s-1}⌉$ 个数，如果满足 $sum≥(c−x)∗s$，则 $⌈\frac{sum}{s-1}⌉>c−x$，此时一定有解。

考虑如何维护 $<s$ 的数的和 $sum$ 与 $\ge s$ 的数的个数 $x$，可以使用splay。将 $s$ 的前驱转到根，$sum$ 即为 $sum_{root}-sum_{rs_{root}}$，$x$ 即为 $siz_{rs_{root}}$。

## [洛谷P4588 - 数学计算](https://www.luogu.com.cn/problem/P4588)
#### 线段树
#### 题意
给定一个初始值为 $1$ 的数 $x$，每次操作将 $x$ 变为 $x\times m$ 或撤销之前的某一次操作。
#### 题解
最终的数可以写作 $m_1\times m_2\times m_3\times \cdots \times m_n$，因此我们可以建一棵线段树储存每个因数并记录区间乘积，即为答案。初始每个因数均为 $1$，操作1即为单点修改，撤销时把对应位置的值修改为 $1$ 即可。

## [洛谷P4198 - 楼房重建](https://www.luogu.com.cn/problem/P4198)
#### 线段树
#### 题解
显然能看到楼房顶端与原点连线的斜率必定单调递增，考虑将高度转化为斜率并用线段树维护。

具体地，每个线段树节点维护区间 $max$ 与区间答案 $len$。难点在于如何进行pushup操作。

维护 $len$ 时，首先左儿子答案必定包含于大区间答案中，显然。对于右儿子我们递归处理。

对于每个区间传入其必须大于的值 $lx$，即左区间的最大值。把右区间分为 $s1,s2$ 分开考虑。如果 $s1$ 最大值 $≤ls$，则没有贡献，递归 $s2$。如果 $s1$ 的最大值大于 $lx$，那么 $s2$ 中剩下的在原区间中做贡献的项一定能贡献到最终答案中。之后去递归 $s1$。

时间复杂度 $O(n \log^2 n)$。

## [洛谷P5490 - 矩形面积并](https://www.luogu.com.cn/problem/P5490)
#### 线段树 扫描线
#### 题意
求 $n$ 个四边平行于坐标轴的矩形的面积并。
#### 题解
扫描线模板题。将矩形的所有横边离线，记录 $x_l,x_r,y$。将下边缘标记为入边，上边缘标记为出边，答案即可拆分为两条线段之间的矩形的面积之和。

自下而上扫描线段，扫描到入边时记录该条线段，扫描到出边删除该条线段。用线段树记录当前存在的线段的长度并 $x$，每次扫描到一条线段时更新 $x$ 并在答案中加上 $x\times (y_{i+1}-y_i)$。

实现细节中，注意线段树的每个叶子节点记录的是区间 $[l,r+1]$ 的信息，这样每个点保留的就是一条线段而不是一个端点了。因为我们将横坐标离散化了，因此一个结点的实际左右端点需要单独记录在结构体中。

## [洛谷P1502 - 窗口的星星](https://www.luogu.com.cn/problem/P1502)
#### 线段树 扫描线
#### 题意
二维平面上有 $n$ 个点，点有点权，求在平面内框一个 $H\times W$ 的矩形，矩形内点权和的最大值。
#### 题解
注意到如果以每个点为左下角建立一个 $H\times W$ 的矩形，如果两个点的矩形有交集就代表它们可以同时被选中，因为可以将矩形框在左下角的星星上，其他星星必定在交集的左下角，因此也可以被框住。

考虑维护交集的权值和。建立完所有矩形后自下而上扫描线段，添加进线段树时将区间 $[x_l,x_r]$ 的点都增加矩形代表点的权值，扫描到出边删除即可，每次添加时更新区间最大值的最大值即为答案。

## [洛谷P4097 - Segment](https://www.luogu.com.cn/problem/P4097)
#### 线段树 李超线段树
#### 题意
在二维平面内维护两个操作：

1. 给定线段的两个端点，将它加入到平面内。
2. 给定 $k$，求与直线 $x=k$ 相交的线段中交点纵坐标最大的线段的编号。

#### 题解
李超线段树模板题。求出每条线段的解析式 $f(x)=kx+b$，用线段树维护 $x$ 轴上所有点的答案。线段树每个结点记录的是区间 $[l,r]$ 中点处的答案。

加入一条线段时，递归更新。扫描到区间 $[l,r]$ 时，
1. 若区间中没有线段，直接将它作为答案，返回。
2. 若它比原线段更优，将它作为当前点答案。
3. 记录在上一步中被淘汰的线段为 $a$，胜出的为 $b$。若在右端点处 $a$ 比 $b$ 优，则它们一定在左区间中产生了交点，递归更新左区间答案，右区间同理。可以参考以下代码：
```cpp
void update(int u,int l,int r,int L,int R,int k){
	if(L<=l&&r<=R){
		if(!id[u]) return id[u]=k,void();//还没有过
		if(f[k].q(mid)-f[id[u]].q(mid)>eps) swap(k,id[u]);
		if(f[k].q(l)-f[id[u]].q(l)>eps||(f[k].q(l)==f[id[u]].q(l)&&k<id[u])) update(ls,l,mid,L,R,k);
		if(f[k].q(r)-f[id[u]].q(r)>eps||(f[k].q(r)==f[id[u]].q(r)&&k<id[u])) update(rs,mid+1,r,L,R,k);
		return;
	}
	if(L<=mid) update(ls,l,mid,L,R,k);
	if(R>mid) update(rs,mid+1,r,L,R,k);
}
```

查询时，由于每个点记录的是点上的答案，无法进行向下更新的操作，因此我们需要从根节点向下递归到查询的点，在路径上不断取 $max$ 即为答案。可以参考以下代码：
```cpp
pair<int,int> query(int u,int l,int r,int k){//返回的是编号和值，编号用于更新答案
	pair<int,int> res;
	if(id[u]) res={f[id[u]].q(k),id[u]};
	if(l==r) return res;
	if(k<=mid) res=_max(query(ls,l,mid,k),res);
	else res=_max(query(rs,mid+1,r,k),res);
	return res;
}
```


## [洛谷P4556 - 雨天的尾巴](https://www.luogu.com.cn/problem/P4556)

#### 线段树 线段树合并
#### 题意
给定一棵树，每次在点 $x$ 到点 $y$ 路径上的每个点增加一个数 $z$，求所有操作完毕后每个点上最多的数。

#### 题解
线段树合并模板题。使用树上差分思想，每次操作可以转化为在 $(1,x),(1,y)$ 上增加 $z$，在 $(1,lca(x,y)),(1,fa_{lca(x,y)})$ 上减少 $z$，从下向上合并后再执行当前点上的操作，此时记录的即为当前点的答案。

在每个点上我们开一棵权值线段树记录每个数的出现次数，于是每次更新就需要将两棵权值线段树合并。如果暴力合并将每个点都相加合并一次复杂度为 $O(n)$，无法接受。但如果是动态开点的线段树，合并时有更加高效的方法。

具体来说，将线段树 $y$ 合并到 $x$ 上，从上到下递归。如果 $x$ 没有左儿子但 $y$ 有，直接将 $y$ 的左儿子接到 $x$ 的左儿子上，就不用向下递归了，如果都有则递归处理。右儿子同理。可以参考以下代码：
```cpp
void merge(int p1,int p2,int l,int r){
	if(l==r){
		ma[p1]=ma[p1]+ma[p2];
		return;
	}
	if(s[p1][0]&&s[p2][0]) merge(s[p1][0],s[p2][0],l,mid);
	else if(s[p2][0]) s[p1][0]=s[p2][0];
	if(s[p1][1]&&s[p2][1]) merge(s[p1][1],s[p2][1],mid+1,r);
	else if(s[p2][1]) s[p1][1]=s[p2][1];
	ma[p1]=max(ma[s[p1][0]],ma[s[p1][1]]);
}
```

深搜整棵树，回溯过程中依次将当前点的所有儿子合并到当前点的权值线段树上，然后执行当前点的加减操作，执行完毕后记录当前点的答案即可。

## [洛谷P3919 - 可持久化线段树1](https://www.luogu.com.cn/problem/P3919)
#### 线段树 主席树
#### 题意
维护一个数列，要求支持在某个历史版本上修改某一个位置上的值、访问某个历史版本上的某一位置的值。每次操作生成一个新的版本。
#### 题解
主席树模板题。主席树即为能维护区间历史信息的一种线段树变体。题目中支持的操作可以用线段树实现，但如果要访问历史版本，通常的想法是每次操作复制一棵完整的线段树，但这样的复杂度无法接受。

注意到每次修改时，仅改变了从根节点到修改点路径上的 $\log n$ 个点，把整棵线段树复制过去显然是不划算的。于是我们仍然对每次操作建一个新的根，但是修改过程中某个点没有更改的子树，就直接指向历史版本的那个子树的位置，对于更改过的再新建结点。这样每次修改的复杂度就是 $O(\log n)$。

具体实现中，update函数传入的就是一个地址，这样就能直接方便地修改某个点的编号。每次修改时先把新根设为历史版本的根传入函数，新建新结点复制历史点的信息后，再递归需要修改的点。这样需要修改的儿子就在下一层递归被自动赋给了当前点记录的左儿子信息。可以参考以下代码：

```cpp
//&u初始传入历史版本的根
void change(int &u,int l,int r,int U,int k){
	tr[++tot]=tr[u]; u=tot;
	if(l==r){
		tr[u].val=k;
		return;
	}
	if(U<=mid) change(tr[u].ls,l,mid,U,k);
	else change(tr[u].rs,mid+1,r,U,k);
	return;
}
```

## [洛谷P3402 - 可持久化并查集](https://www.luogu.com.cn/problem/P3402)
#### 线段树 主席树
#### 题意
给定 $n$ 个集合，集合 $i$ 初始包含数 $i$。要求支持合并两集合、回到之前操作以及询问两数是否属于同一集合。
#### 题解
注意到并查集合并两集合，发生变化的仅是其中一个集合根节点的父亲。因此只需要对 $fa$ 数组可持久化即可。每次回退时将这次操作的根节点指向历史版本的根。合并操作就在上一步的基础上进行。

如果要实现可持久化，就不能用路径压缩来优化，因为每次执行 $find$ 操作都会改变好多个点的父亲。因此我们需要用按秩合并优化，此时就需要多记录每个集合的 $size$。这个数组也需要可持久化。

注意，$fa$ 和 $size$ 并不能在一棵主席树上记录，因为每次合并更改旧根的 $fa$ 和新根的 $size$。所以需要开两个。


## [洛谷P3834 - 可持久化线段树2](https://www.luogu.com.cn/problem/P3834)
#### 线段树 主席树
#### 题意
给定一个数列，每次查询区间 $[l,r]$ 的第 $k$ 小值。
#### 题解
查询固定区间的第 $k$ 小值可以用权值线段树维护，查询时如果左子树的数量 $s\ge k$ 则在左子树中找第 $k$ 大，否则在右子树中找第 $k-s$ 大。

但是问题中的区间是不固定的，如何快速获取询问区间的权值线段树？

注意到权值线段树满足类似前缀和的性质，即区间 $[l,r]$ 对应的树可以由区间 $[1,r]$ 和区间 $[1,l-1]$ 对应的树相减得到，于是我们需要维护每个位置的前缀权值线段树。

并不需要对每个位置建一棵新树，我们可以使用主席树的技巧。从左往右建树时，每次仅多了当前点的信息，于是我们可以只添加根节点到当前点的数路径上的 $\log n$ 个结点，其余点直接指向历史版本即可。使用主席树维护

每次查询时，不需要真正相减建出一棵新树，只需同时在两棵树上递归，在每个位置上将两棵树的点相减即可。可以参考以下代码：
```cpp
int query(int u,int v,int l,int r,int k){
	if(l==r) return l;
	int s=tr[tr[u].ls].cnt-tr[tr[v].ls].cnt;
	if(s>=k) return query(tr[u].ls,tr[v].ls,l,mid,k);
	else return query(tr[u].rs,tr[v].rs,mid+1,r,k-s);
}
```

## [洛谷P2633 - Count on a tree](https://www.luogu.com.cn/problem/P2633)
#### 线段树 主席树
#### 题意
给定一棵树，点有点权，每次询问 $u,v$ 路径上第 $k$ 小点权。
#### 题解
本题与上一题类似，只是换到了树上。考虑如何使用前缀和技巧获取 $u,v$ 路径上对应的权值线段树。

仍然使用主席树，从根节点开始搜索，每个点在它父亲点的基础上增加它的信息。这样我们就可以快速查询。设点 $i$ 对应的前缀权值线段树为 $c_i$，则 $u,v$ 路径上的权值线段树即为 $c_u+c_v-c_{lca(u,v)}-c_{fa_{lca(u,v)}}$。在它上面查询即可。

## [洛谷P3302 - 森林](https://www.luogu.com.cn/problem/P3302)
#### 线段树 主席树
#### 题意
给定一片森林，要求支持查询两点路径上第 $k$ 小权值以及在两点之间连边，保证连边后仍是森林。
#### 题解
这题和上一题的区别在于增加了连边（合并两棵树）的操作。如果要用主席树维护 $k$ 小权值，合并就必须要暴力合并。每次合并在两点间连一条边，并将小树的根节点的父亲设置为大树的根节点。此时小树上主席树应该发生变化，我们直接从小树的根开始暴力dfs重构即可。

## [洛谷P4585 - 火星商店问题](https://www.luogu.com.cn/problem/P4585)
#### Trie树 主席树
太难以后写

## [洛谷P2801 - 教主的魔法](https://www.luogu.com.cn/problem/P2801)
#### 分块
#### 题意
维护一个数列，支持区间加与查询区间内 $\ge k$ 的数的个数。
#### 题解
$k$ 是变化的，所以不能使用线段树之类的数据结构维护。这种不可合并的问题可以使用分块。

具体地，将整个区间分成若干块，每块长度为 $\sqrt n$。预处理每块的左端点 $L_i$，右端点 $R_i$ 和每个点属于的块 $bel_i$。在处理过程中不断维护每个块内部都排好序的数列 $b$。

将 $[l,r]$ 同时加上 $k$，可以将区间分成三段处理。
- 对于区间开头的没有被完全覆盖的块 $bel_l$，直接暴力将 $[l,R_{bel_l}]$ 每个数加上 $k$。之后对块重新排序。区间末尾没被完全覆盖的块同理。
- 对于被区间完全覆盖的块，对每个块维护一个标记 $add$，直接对 $add$ 加上 $k$ 即可。区间内数 $i$ 的实际值即为 $i+add$。

特别地，如果修改区间的左右端点属于同一个块，暴力修改后排序即可。

查询时同样，对于前后未被覆盖的块暴力遍历统计，对于被完全覆盖的块，排序后在内部二分即可。

## [洛谷P3203 - 弹飞绵羊](https://www.luogu.com.cn/problem/P3203)
#### 分块
#### 题解
使用分块，对每个点维护跳出该块需要的次数以及跳出该块后到达的点。这个可以 $O(n)$ 预处理。修改时直接将块内所有点暴力重构一遍即可。

询问时一块一块跳，每次累加答案直到跳出去。

